name: AI Security Pipeline
on: [push]

jobs:
  security-analysis:
    name: Local Security Scan
    runs-on: self-hosted
    # We remove 'defaults: run: shell: bash' so it uses the default Windows PowerShell
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Bundle Code for Scanning
        run: |
          Write-Output "ðŸ“¦ Packaging code..."
          # git archive works perfectly in PowerShell too
          git archive --format=tar.gz -o source_code.tar.gz HEAD

      - name: Send to AI Engine
        run: |
          Write-Output "ðŸš€ Sending to Django API at http://localhost:8000..."
          
          # 1. Capture Git Metadata using PowerShell syntax
          $REPO_NAME = "${{ github.repository }}"
          $COMMIT_HASH = git rev-parse HEAD
          $BRANCH_NAME = "${{ github.ref_name }}"
          $AUTHOR_EMAIL = git log -1 --pretty=format:'%ae'

          Write-Output "   - Repo: $REPO_NAME"
          Write-Output "   - Commit: $COMMIT_HASH"
          Write-Output "   - Branch: $BRANCH_NAME"

          # 2. Send POST request
          # We use '& curl.exe' to force using the actual Curl tool, not the PowerShell alias
          & curl.exe -s -o response.json -w "%{http_code}" -X POST http://localhost:8000/api/scan/upload/ `
            -F "file=@source_code.tar.gz" `
            -F "repo_name=$REPO_NAME" `
            -F "commit_hash=$COMMIT_HASH" `
            -F "branch=$BRANCH_NAME" `
            -F "triggered_by=$AUTHOR_EMAIL"

          # 3. Read the response code (stored at the end of the output or handled via logic)
          # For simplicity in PowerShell, we just check if the file exists and print it
          if (Test-Path response.json) {
             Get-Content response.json
          }